
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: dev_nb/gui_building.sync.ipynb
import torch

from torch.functional import Tensor

import SimpleITK as sitk

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.widgets import Slider, RangeSlider
import ipywidgets 
plt.ion()
import ipdb
tr = ipdb.set_trace
# %%

import matplotlib as mpl
from matplotlib import pyplot as plt
def discrete_cmap():
    cmap = plt.cm.jet  # define the colormap
# extract all colors from the .jet map
    cmaplist = [cmap(i) for i in range(cmap.N)]
# force the first color entry to be grey
    cmaplist[0] = (.0, .0, .0, 1.0)
# create the new map
    cmap = mpl.colors.LinearSegmentedColormap.from_list(
        'Custom cmap', cmaplist, cmap.N)

    bounds = np.linspace(0, 255, 256)
    norm = mpl.colors.BoundaryNorm(bounds, cmap.N)
    return cmap, norm
def discrete_cmap(N, base_cmap=None):
    """Create an N-bin discrete colormap from the specified input map"""

    # Note that if base_cmap is a string or None, you can simply do
    #    return plt.cm.get_cmap(base_cmap, N)
    # The following works for string, None, or a colormap instance:

    base = plt.cm.get_cmap(base_cmap)
    color_list = base(np.linspace(0, 1, N))
    cmap_name = base.name + str(N)
    return base.from_list(cmap_name, color_list, N)
import numpy as np
x = np.random.rand(20)  # define the data
y = np.random.rand(20)  # define the data
tag = np.random.randint(0, 20, 20)

def fix_labels(x):
            if x.GetPixelID()==22:
                x = sitk.Cast(x,sitk.sitkUInt8)
            return x
            

def view_sitk(img,mask,dtypes='im',**kwargs):
    img = fix_labels(img)
    mask = fix_labels(mask)
    img,mask=list(map(sitk.GetArrayFromImage,[img,mask]))
    ImageMaskViewer([img,mask],dtypes,**kwargs)


def view_3d_np(x):
    ImageMaskViewer([np.expand_dims(x[0],0), np.expand_dims(x[1],0)])
def view_5d_torch(x,n=0):
    ImageMaskViewer([x[0][n,0,:].cpu().detach().numpy(),x[1][n,0,:].cpu().detach().numpy()])

def view(a,b,n=0, cmap_img='Greys_r', cmap_mask='RdPu_r'):
    '''
    4d or 5d input possible, tensor or numpy array
    '''
    
    if  len(a.shape)>4: # i.e., has batch etc
            a,b = [x[n] for x in [a,b]]
    arrs = []
    for arr in a,b:
        if isinstance(arr,Tensor):
            arr = arr.cpu().detach().numpy()
            arrs.append(arr)
        else:
            arrs.append(arr)
    ImageMaskViewer(arrs,
                     # nn.Sigmoid()(b[n, 0, :]).cpu().detach().numpy()],
                    cmap_img=cmap_img,
                    cmap_mask=cmap_mask)



def get_window_level_numpy_array(
    image_list,
    intensity_slider_range_percentile=[2, 98],
    dtypes='im'
):
    # to the original images. If they are deleted outside the view would become
    # invalid, so we use a copy wich guarentees that the gui is consistent.
    if isinstance(image_list[0] ,np.ndarray):  # if images are already np_array..
        npa_list = image_list
    elif isinstance(image_list[0], torch.Tensor):
        image_list = [a.detach().cpu() for a in image_list]
        npa_list = [image_list[0].numpy(), image_list[1].numpy()]

    else:
        npa_list = list(map(sitk.GetArrayFromImage, image_list))

    wl_range = []
    wl_init = []
    # We need to iterate over the images because they can be a mix of
    # grayscale and color images. If they are color we set the wl_rangenotebooks/nbs/gui_building.sync.py
    # to [0,255] and the wl_init is equal, ignoring the window_level_list
    # entry.
    for npa, data_type in zip(npa_list, dtypes):
        if data_type == "i":
            min_max = np.percentile(npa.flatten(),
                                    intensity_slider_range_percentile)
        else:
            min_max = [npa.min(), npa.max()]
        wl_range.append((min_max[0], min_max[1]))
        wl_init.append(wl_range[-1])
    return (npa_list, wl_range, wl_init)


# %%

# %%
# %%

class ImageMaskViewer(object):
    '''
    expects numpy  depth x width x height
    '''
    
    def __init__(self,
                 image_list,
                 dtypes="im",
                 figure_size=(10, 8),
                 intensity_slider_range_percentile=[2, 98],
                 cmap_img= 'Greys_r',
                 cmap_mask = None,
                 apply_transpose=True) ->None:
        self.cmap_img ,self.cmap_mask, self.dtypes= cmap_img, cmap_mask, dtypes

        self.npa_list, self.wl_range, self.wl_init = get_window_level_numpy_array(
            image_list, intensity_slider_range_percentile, self.dtypes)

        # if apply_transpose==True :
        #     self.npa_list= [a.transpose(2,1,0) for a in self.npa_list]
        self.fig, self.axises = plt.subplots(1, 2, figsize=figure_size)
        self.axamp = plt.axes([0.1, 0.05, 0.8, 0.03])
        self.axamp_wl = plt.axes([0.1, 0.0, 0.8, 0.03])
        self.slider = Slider(ax=self.axamp,
                             label="image",
                             valmin=0,
                             valmax=self.npa_list[0].shape[0] - 1,
                             valstep=1)
        self.slider_wl = RangeSlider(ax=self.axamp_wl,
                                     label="Window level",
                                     valmin=self.wl_range[0][0],
                                     valmax=self.wl_range[0][1])
        self.ax_imgs = self.create_images()
        self.slider.on_changed(self.update_fig_fast)
        self.slider_wl.on_changed(lambda vals: self.ax_imgs[0].set_clim(*vals))
        plt.tight_layout()

    def create_images(self):
        ax_imgs=[]
        for ax, img, data_type in zip(self.axises, self.npa_list,
                                      self.dtypes):

            img_slice = img[0,:,:]
            if data_type == 'm':
                if not self.cmap_mask:
                    N = img.max()
                    # cmap = discrete_cmap(N,'cubehelix')
                    # ax_imgs.append(ax.imshow(img_slice,cmap=cmap))
                    cmap_mask ='nipy_spectral'
                    ax_imgs.append(ax.imshow(img_slice,cmap=cmap_mask,vmin=img.min(),vmax=img.max() ))
                else:
                    ax_imgs.append(ax.imshow(img_slice,cmap=self.cmap_mask,vmin=img.min(),vmax=img.max() ))

            else:
                ax_imgs.append(ax.imshow(img_slice,
                          cmap=self.cmap_img,
                          vmin=self.slider_wl.val[0],
                          vmax=self.slider_wl.val[1]))
        return ax_imgs

    def update_fig_fast(self,val):
        for i, img in enumerate(self.npa_list):
            img_slice = img[val,:,:]
            self.ax_imgs[i].set_array(img_slice)

# %%
class ImageMaskViewer_J():
    '''
    viewer for jupyter
    expects images of type ndarray strictly
    '''
    
    def __init__(self, f):
        self.arg1 = 110
        self.arg2 = 15
        self.f = f

    def __call__(self,*args,**kwargs):

        self.image_list, self.data_types= self.f(*args,**kwargs)
        self.image_list, self.wl_range, self.wl_init = get_window_level_numpy_array(
            self.image_list,[2,98],  self.data_types)

        horizontal =True
        figure_size=(10, 8)
        # Create a figure.
        col_num, row_num = (len(self.image_list), 1) if horizontal else (1, len(self.image_list))
        self.fig, self.axes = plt.subplots(row_num, col_num, figsize=figure_size)
        if len(self.image_list) == 1:
            self.axes = [self.axes]
        self.fig, self.axises = plt.subplots(1, 2, figsize=figure_size)

        self.cmap_img = 'Greys_r'
        self.cmap_mask='Greys_r'
        self.create_ui()
        self.update_fig(0)



    def create_ui(self):
        self.axamp = plt.axes([0.1, 0.05, 0.8, 0.03])
        self.axamp_wl = plt.axes([0.1, 0.0, 0.8, 0.03])
        self.slider =ipywidgets.IntSlider(ax=self.axamp,
                             label="image",
                             valmin=0,
                             valmax=self.image_list[0].shape[1] - 1,
                             valstep=1)
        self.slider_wl = ipywidgets.IntRangeSlider(ax=self.axamp_wl,
                                     label="Window level",
                                     valmin=self.wl_range[0][0],
                                     valmax=self.wl_range[0][1])
        self.slider.observe(self.update_fig)
        self.slider_wl.on_changed(self.change_fig_windowing)
        plt.tight_layout()

    def update_fig(self, val):
        for ax, img, data_type in zip(self.axises, self.image_list,
                                      self.data_types):
            img_slice = img[:,val,:].transpose(1,2,0)
            if data_type == 'mask':
                ax.imshow(img_slice,cmap=self.cmap_mask)

            else:
                ax.imshow(img_slice,
                          cmap=self.cmap_img,
                          vmin=self.slider_wl.val[0],
                          vmax=self.slider_wl.val[1])

    def change_fig_windowing(self, wl_range):
        tr()
        self.axises[0].imshow(self.image_list[0][self.slider.val, :],
                              cmap=self.cmap_img,
                              vmin=wl_range[0],
                              vmax=wl_range[1])



# %%
@ImageMaskViewer_J
def viewer(*arrs):
    output_arrays=[]
    for ind,_ in enumerate(arrs):
        if type(arrs[ind]) == torch.Tensor:
            arrs_np = arrs[ind].numpy()
            output_arrays.append(arrs_np)
        else:
            output_arrays.append(arrs[ind])
    return output_arrays, ["img","mask"]


# %%
# %%

from matplotlib.widgets import RangeSlider, Slider


def view(*arrays,n=0, cmap_img='Greys_r', cmap_mask='RdPu_r'):
    if  len(arrays[0].shape)>4: # i.e., has batch etc
            arrays = [x[n] for x in arrays]

    for indx in range(len(arrays)):
        if isinstance(arrays[indx],Tensor) :
            arrays[indx] = arrays[indx].cpu().detach().numpy()
    ImageMaskViewer(arrays,
                     # nn.Sigmoid()(b[n, 0, :]).cpu().detach().numpy()],
                    cmap_img=cmap_img,
                    cmap_mask=cmap_mask)


# %%
def get_window_level_numpy_array(
    image_list,
    intensity_slider_range_percentile=[2, 98],
    data_types=["img", "mask"],
):
    # to the original images. If they are deleted outside the view would become
    # invalid, so we use a copy wich guarentees that the gui is consistent.
    if isinstance(image_list[0] ,np.ndarray):  # if images are already np_array..
        npa_list = image_list
    elif isinstance(image_list[0] ,torch.Tensor):  # if images are already np_array..type(image_list[0]) == torch.Tensor:
        npa_list = [image_list[0].numpy(), image_list[1].numpy()]

    else:
        npa_list = list(map(sitk.GetArrayFromImage, image_list))

    wl_range = []
    wl_init = []
    # We need to iterate over the images because they can be a mix of
    # grayscale and color images. If they are color we set the wl_rangenotebooks/nbs/gui_building.sync.py
    # to [0,255] and the wl_init is equal, ignoring the window_level_list
    # entry.
    for npa, data_type in zip(npa_list, data_types):
        if data_type == "img":
            min_max = np.percentile(npa.flatten(),
                                    intensity_slider_range_percentile)
        else:
            min_max = [npa.min(), npa.max()]
        wl_range.append((min_max[0], min_max[1]))
        wl_init.append(wl_range[-1])
    return (npa_list, wl_range, wl_init)


# %%


# %%
if __name__ =="__main__":

    i = np.load('toydata/image.npy')
    m = np.load('toydata/preds.npy')[0]
    I = ImageMaskViewer([i,m])
# %%
    I = ImageMaskViewer([i2,m2],intensity_slider_range_percentile=[0,100])
# %%
    image_list, data_types= [i2,m2],["image","mask"]
    image_list, wl_range, wl_init = get_window_level_numpy_array(
        image_list,[2,98],  data_types)

# %%
    horizontal =True
    figure_size=(10, 8)
    # Create a figure.
    col_num, row_num = (len(image_list), 1) if horizontal else (1, len(image_list))

    # viewer expects 4d input
    viewer(np.expand_dims(i,0),m)
# %%
